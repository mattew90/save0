/*! SmartUpscale by Marat Tanalin | http://tanalin.com */

const propertyName  = 'image-rendering',
      styleAttrName = 'style',
      autoValue     = 'auto',
      propertyValue = 'pixelated',
      processDelay  = 500,
      scrollDelay   = 100;

let androidFactor = 1,
    android       = false;

let options, observer;

function getRendering(image) {
	return getComputedStyle(image, null).getPropertyValue(propertyName);
}

function setRendering(image, value) {
	const style    = image.style;
	let   oldValue = style.imageRendering;

	if ('' === oldValue) {
		oldValue = autoValue;
	}

	if (oldValue !== value) {
		style.imageRendering = value;

		if (image.getAttribute(styleAttrName) === propertyName + ': ' + autoValue + ';') {
			image.removeAttribute(styleAttrName);
		}
	}
}

/* saveRendering(), restoreRendering(). */
{
	const map = new WeakMap;

	function saveRendering(image) {
		if (map.has(image)) {
			return;
		}

		map.set(image, getRendering(image));
	}

	function restoreRendering(image) {
		if (map.has(image)) {
			setRendering(image, map.get(image));
		}
	}
}
/* /saveRendering(), restoreRendering(). */

/* addScrollEndListener() */
{
	const listeners = [];
	let   timeout   = 0;

	const callListener = listener => {
		listener();
	};

	const callListeners = () => {
		listeners.forEach(callListener);
	};

	const scrollListener = () => {
		window.clearTimeout(timeout);
		timeout = window.setTimeout(callListeners, scrollDelay);
	};

	function addScrollEndListener(listener) {
		if (0 === listeners.length) {
			window.addEventListener('scroll', scrollListener);
		}

		listeners.push(listener);
	}
}
/* /addScrollEndListener() */

function elementInViewport(element) {
	const rect             = element.getBoundingClientRect(),
	      scrollingElement = document.scrollingElement,
	      clientWidth      = scrollingElement.clientWidth,
	      clientHeight     = scrollingElement.clientHeight;

	// If any of four element corners is in viewport, the element is partially visible.
	return rect.right > 0 && rect.bottom > 0 && rect.left < clientWidth && rect.top < clientHeight;
}

function getFileExtension(path) {
	var hashPos = path.indexOf('#');

	if (-1 !== hashPos) {
		path = path.slice(0, hashPos);
	}

	var qPos = path.indexOf('?');

	if (-1 !== qPos) {
		path = path.slice(0, qPos);
	}

	var dotPos = path.lastIndexOf('.');

	return -1 === dotPos ? null : path.slice(dotPos + 1);
}

function isVector(image) {
	return 'svg' === getFileExtension(image.src);
}

function isInteger(number) {
	return Math.floor(number) === number;
}

function isPixelRatioReal() {
	if (!android) {
		return true;
	}

	const element = document.querySelector('META[name="viewport"]');

	return element && element.content.includes('width=device-width');
}

function getImages() {
	return Array.from(document.querySelectorAll('img, input[type="image"]'));
}

function getImagesInViewport() {
	return getImages().filter(elementInViewport);
}

function getAndroidFactor() {
	return window.outerWidth / window.innerWidth;
}

function getPixelRatio() {
	let ratio = window.devicePixelRatio;

	if (android) {
		ratio *= getAndroidFactor();
	}

	return ratio;
}

function getFloatStyle(computedStyle, propName) {
	return parseFloat(computedStyle.getPropertyValue(propName));
}

function getImageSize(elem) {
	const style = getComputedStyle(elem, null);

	if ('none' === style.getPropertyValue('display')) {
		return null;
	}

	let width  = getFloatStyle(style, 'width'),
	    height = getFloatStyle(style, 'height');

	if ('border-box' === style.getPropertyValue('box-sizing')) {
		const borderWidth   = getFloatStyle(style, 'border-left-width') + getFloatStyle(style, 'border-right-width'),
		      borderHeight  = getFloatStyle(style, 'border-top-width')  + getFloatStyle(style, 'border-bottom-width'),
		      paddingWidth  = getFloatStyle(style, 'padding-left')      + getFloatStyle(style, 'padding-right'),
		      paddingHeight = getFloatStyle(style, 'padding-top')       + getFloatStyle(style, 'padding-bottom');

		width  -= (borderWidth  + paddingWidth);
		height -= (borderHeight + paddingHeight);
	}

	return {
		width  : width,
		height : height
	}
}

function getImageZoom(image) {
	if (image.srcset.trim().length && image.src !== image.currentSrc) {
		return 0;
	}

	const size = getImageSize(image);

	if (null === size) {
		return 0;
	}

	const x = size.width  / image.naturalWidth,
	      y = size.height / image.naturalHeight;

	if (x !== y) {
		return 0;
	}

	let zoom = x * getPixelRatio();

	if (!isInteger(zoom)) {
		const zoomRounded = Math.round(zoom * 1000) / 1000;

		if (isInteger(zoomRounded)) {
			zoom = zoomRounded;
		}
	}

	return zoom;
}

function processImageLoadListener(event) {
	processLoadedImage(event.target);
}

function processLoadedImage(image) {
	const zoom = getImageZoom(image);

	if (zoom > 1 && isInteger(zoom) && (0 === options.maxzoom || zoom <= options.maxzoom)) {
		setRendering(image, propertyValue);
	}
	else {
		restoreRendering(image);
	}

	if (!options.observe) {
		image.removeEventListener('load', processImageLoadListener);
	}
}

function processImage(image) {
	if (isVector(image)) {
		return;
	}

	saveRendering(image);

	const complete = image.complete;

	if (!complete || options.observe) {
		image.addEventListener('load', processImageLoadListener);
	}

	if (complete) {
		processLoadedImage(image);
	}
}

function processImmediately() {
	getImagesInViewport().forEach(processImage);
}

/* process() */
{
	let lastTime = 0,
	    timeout  = 0,
	    waiting  = false;

	function process() {
		const diff = Date.now() - lastTime;

		if (diff < processDelay) {
			if (!waiting) {
				waiting = true;

				window.clearTimeout(timeout);

				timeout = window.setTimeout(() => {
					waiting = false;
					process();
				}, processDelay - diff + 1);
			}
		}
		else {
			lastTime = Date.now();
			processImmediately();
		}
	}
}
/* /process() */

function applyGlobally() {
	const style = document.createElement('style');
	style.textContent = '*, :before, :after {' + propertyName + ': ' + propertyValue + ' !important; }';
	document.head.appendChild(style);
}

function androidProcess() {
	const newFactor = getAndroidFactor();

	if (androidFactor === newFactor) {
		return;
	}

	androidFactor = newFactor;
	process();
}

function initAndroid() {
	if (!android) {
		return;
	}

	document.documentElement.addEventListener('touchend', androidProcess);
	screen.addEventListener('orientationchange', androidProcess);
}

function initResize() {
	window.addEventListener('resize', process);
}

function initScroll() {
	addScrollEndListener(process);
}

function createObserver() {
	const observer = new MutationObserver(process);

	observer.observe(document, {
		childList     : true,
		subtree       : true,
		attributes    : true,
		characterData : true
	});

	return observer;
}

function initObserver() {
	if (options.observe) {
		observer = createObserver();
	}
}

function getOs(callback) {
	browser.runtime.sendMessage(
		{message: 'getOs'},
		message => {
			android = 'android' === message.os;
			callback();
		}
	);
}

function init(aOptions) {
	options = aOptions;

	if (options.global) {
		applyGlobally();
		return;
	}

	getOs(() => {
		if (!isPixelRatioReal()) {
			return;
		}

		initAndroid();
		initResize();
		initScroll();
		initObserver();
		process();
	});
}

getOptions(init);